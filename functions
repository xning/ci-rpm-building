# anzhou94@gmail.com
# requirements:
# krb5-workstation perl-Authen-Krb5

# Take care pls, in shell, 0 is true, and others are false.
# We follow this tradition in the following functions.
T=0
F=1

LANG=C # To make no trouble, we only use English

# Here, the most important argument for these functions is
# the user name.

# Common functions
function wait_a_while {
    sleep 3
}

function get_current_user_name {
    id -u -n
}

# Functions for kerberos

# Accept kerb principle as argument
# F.g., is_krb5_full_principal "anzhou94@DOMAIN.COM"
function is_krb5_full_principal {
    (
        T=0 # True
        F=1 # False
        LANG=C
        [ $# -lt 1 -o -z "$1" ] && return ${F:-1}
        krb_domain=$(echo "$1" | cut -s -d '@' -f 2)
        [ -z "${krb_domain}" ] && return ${F:-1}
        return ${T:-0}
    )
}

function get_krb5_default_realm {
    perl -E 'use Authen::Krb5;Authen::Krb5::init_context();say Authen::Krb5::get_default_realm()'
}

function get_krb5_cache_file_name {
    (
        T=0 # True
        F=1 # False
        LANG=C
        [ $# -ge 1 -a -n "$1" ] && user="$1"
        if ! is_krb5_full_principal "${user:-${USER}}";then
            user="${user:-${USER}}@$(get_krb5_default_realm)"
            is_krb5_full_principal "${user}" || return ${F:-1}
        fi
        escape_user=$(echo "${user}" | sed 's/\./\\\./' -)
        klist -l | grep -q -e "^${escape_user} \+" || return ${F:-1}
        cache_file=$(klist -l | grep -e "^${escape_user} \+" | cut -s -d ':' -f 2 | sed 's/ (Expired)$//')
        [ -z "${cache_file}" ] && return ${F:-1}
        echo $cache_file
        return ${T:-0}
    )
}

function is_tgt_forwardable {
    (
        T=0 # True
        F=1 # False
        LANG=C
        [ $# -ge 1 -a -n "$1" ] && user="$1"
        if ! is_krb5_full_principal "${user:-${USER}}";then
            user="${user:-${USER}}@$(get_krb5_default_realm)"
            is_krb5_full_principal "${user}" || return ${F:-1}
        fi
        cache_file=$(get_krb5_cache_file_name "${user}")
        [ -z "${cache_file}" ] && return ${F:-1}
        klist -f ${cache_file} | grep -A 2 'krbtgt/' | head -2 | grep 'Flags:' | sed 's/^.*Flags: \+\(.*\)$/\1/' | grep -q F || return ${F:-1}
        return ${T:-1}
    )
}

# is_tgt_valid_after user_name 3600
function is_tgt_vaild_after {
    (
        T=0 # True
        F=1 # False
        LANG=C
        valid_time=300
        interval=15
        [ $# -ge 1 -a -n "$1" ] && user="$1"
        [ $# -ge 2 -a -n "$2" ] && valid_time=$2 && valid_time=$((valid_time+$interval))
        if ! is_krb5_full_principal "${user:-${USER}}";then
            user="${user:-${USER}}@$(get_krb5_default_realm)"
            is_krb5_full_principal "${user}" || return ${F:-1}
        fi
        cache_file=$(get_krb5_cache_file_name "${user}")
        [ -z "${cache_file}" ] && return ${F:-1}
        expire_time=$(date -d "$(LC_TIME=C klist ${cache_file} | grep 'krbtgt/' | head -1 | sed 's/ \+/ /g' | cut -s -d ' ' -f 3-4)" +"%s")
        current_time=$(date +"%s") && current_time=$((current_time+${valid_time}))
        [ ${expire_time} -gt ${current_time} ] && return ${T:-0}
        return ${F:-1}
    )
}

# Accept kerb principle or user name as principle.
# If no argument, the function will use env USER.
# If no realm gaven, will use the defalut realm.
# The ticket's expire time should be long than 300s
function is_tgt_ok {
    (
        T=0 # True
        F=1 # False
        LANG=C
        valid_time=300
        [ $# -ge 1 -a -n "$1" ] && user="$1"
        is_krb5_full_principal "${user:-${USER}}" || user="${user:-${USER}}@$(get_krb5_default_realm)"
        is_krb5_full_principal "${user}" || return ${F:-1}
        is_tgt_forwardable "${user}" || return ${F:-1}
        is_tgt_vaild_after "${user}" ${valid_time} || return ${F:-1}
        return ${T:-1}
    )
}

# Functions for sftp

# We expect you can always tell us where (the host)
# who (the user) and the workspace (the dir) when
# we sftp/ssh a server
# So, we always begin at a known place
# F.g., ssh_config 192.168.11.231 anzhou94 '/home/anzhou94/'
##
# First login, we need import the server key, and the bad news
# is, if we do this in script, we need an automatically solution.
# While it's not as easy as we we think. So, we just gives
# useful commands:
# ssh-keyscan hostname >> ~/.ssh/known_hosts
# If you need hash the output, use the following command
# ssh-keyscan -H hostname >> ~/.ssh/known_hosts
# If you need make sure whether or not the server key has been in
# known_hosts file, you can do as follows
# ssh-keygen -F hostname || ssh-keyscan -H hostname >> ~/.ssh/known_hosts
# Now is_ssh_ok will import ssh server key automatically.
# ssh_config [server [user [[workdir hash_known_host]]]]
function ssh_config {
    export CI_RPM_SSH_SERVER=localhost
    export CI_RPM_SSH_USER=${USER}
    export CI_RPM_SSH_WORK_DIR='~'
    export CI_SSH_HASH_KNOWN_HOSTS=${T:-0}
    [ $# -ge 1 -a -n "$1" ] && export CI_RPM_SSH_SERVER=$1
    [ $# -ge 2 -a -n "$2" ] && export CI_RPM_SSH_USER=$2
    [ $# -ge 3 -a -n "$3" ] && export CI_RPM_SSH_WORK_DIR=$3
    [ $# -ge 4 -a -n "$4" ] && export CI_SSH_HASH_KNOWN_HOSTS=$4
    echo "${CI_RPM_SSH_SERVER}:${CI_RPM_SSH_USER}:${CI_RPM_SSH_WORK_DIR}:${CI_SSH_HASH_KNOWN_HOSTS}"
    return ${F:-0}
}

# Will automatically import ssh server key.
function is_ssh_ok {
    (
        LANG=C
        [ ${CI_SSH_HASH_KNOWN_HOSTS:-0} -eq 0 ] && opt='-H' || opt=''
        ssh-keygen -q -F ${CI_RPM_SSH_SERVER:-localhost} > /dev/null 2>&1 || ssh-keyscan ${opt} ${CI_RPM_SSH_SERVER:-localhost} >> ~/.ssh/known_hosts 2>/dev/null
        ssh -o PasswordAuthentication=no -K ${CI_RPM_SSH_USER:-${USER}}@${CI_RPM_SSH_SERVER:-localhost} ':' > /dev/null 2> /dev/null
    )
}

function ssh_upload {
    (
        LANG=C
        t=$(mktemp)
        [ -n "${CI_RPM_SSH_WORK_DIR}" -a ${CI_RPM_SSH_WORK_DIR} != '~' ] && echo "cd ${CI_RPM_SSH_WORK_DIR}" > $t
        for f in "$@";do [ -n "$f" ] && echo "put '$f'" >> $t;done
        sftp -oGSSAPIAuthentication=yes -b $t ${CI_RPM_SSH_USER:-${USER}}@${CI_RPM_SSH_SERVER:-localhost}
        ret=$?
        rm -f $t
        return ${ret}
    )
}

function ssh_download {
    (
        LANG=C
        t=$(mktemp)
        [ -n "${CI_RPM_SSH_WORK_DIR}" -a ${CI_RPM_SSH_WORK_DIR} != '~' ] && echo "cd ${CI_RPM_SSH_WORK_DIR}" > $t
        for f in "$@";do [ -n "$f" ] && echo "get '$f'" >> $t;done
        sftp -oGSSAPIAuthentication=yes -b $t ${CI_RPM_SSH_USER:-${USER}}@${CI_RPM_SSH_SERVER:-localhost}
        ret=$?
        rm -f $t
        return ${ret}
    )
}

function ssh_exec {
    (
        LANG=C
        for c in "$@";do { [ -z "$s" -a -n "$c" ] && s=$c; } || { [ -n "$c" ] && s="$s;$c"; } done
            [ -n "${CI_RPM_SSH_WORK_DIR}" -a ${CI_RPM_SSH_WORK_DIR} != '~' ] && echo s="cd '${CI_RPM_SSH_WORK_DIR}';$s"
            ssh -K ${CI_RPM_SSH_USER:-${USER}}@${CI_RPM_SSH_SERVER:-localhost} "$s"
    )
}

# Functions for koji

# If need set tag for the following koji functions,
# pls use the koji_config function like this:
#       koji_config tag
# Default tag is eng-rhel-6. This default action works well
# even you don't run koji_config function first.
# koji_config build_tag result_tag raw_data
function koji_config {
    [ $# -ge 1 -a -n "$1" ] && export CI_RPM_KOJI_BUILD_TAG="$1"
    [ $# -ge 2 -a -n "$2" ] && export CI_RPM_KOJI_RESULT_TAG="$2"
    [ $# -ge 3 -a -n "$3" ] && export CI_RPM_KOJI_RAW="$3"
    echo ${CI_RPM_KOJI_BUILD_TAG:-eng-rhel-6}:${CI_RPM_KOJI_RESULT_TAG:-eng-rhel-6-candidate}:${CI_RPM_KOJI_RAW:-1}
}

function have_koji_to_login {
    koji moshimoshi > /dev/null 2> /dev/null
}

# get_pkgs_owned_by [user]
function get_pkgs_owned_by {
    (
        T=0 # True
        F=1 # False
        LANG=C
        [ $# -ge 1 -a -n "$1" ] && user="$1"

        koji list-pkgs --quiet --owner=${user:-${USER}} --tag ${CI_RPM_KOJI_BUILD_TAG:-eng-rhel-6} 2>/dev/null | cut -s -d ' ' -f 1
    )
}

# get_rpm_from_pkg pkg
function get_rpm_from_pkg {
    (
        T=0 # True
        F=1 # False
        LANG=C
        [ $# -eq 1 -a -n "$1" ] || return ${F:-1}
        if [ ${CI_RPM_KOJI_RAW:-1} -eq 1 ];then
            koji list-tagged --quiet --paths --rpms ${CI_RPM_KOJI_RESULT_TAG:-eng-rhel-6-candidate} "$1" | awk -F '/' '{print $NF}' | sort | uniq
        else
            koji list-tagged --quiet --paths --rpms ${CI_RPM_KOJI_RESULT_TAG:-eng-rhel-6-candidate} "$1" | sort | uniq
        fi
    )
}

# This function will output such infos
# build_id:task_id:rpm_owner:built_time
# The built_time is UTC time. You can display it as locale time as follows
# date -d @1369623600
# get_rpm_info_idx rpm
function get_rpm_info_idx {
    (
        T=0 # True
        F=1 # False
        LANG=C
        [ $# -eq 1 -a -n "$1" ] || return ${F:-1}
        s=$(koji rpminfo "$1" || return ${F:-1})
        [ -n "$s" ] || return ${F:-1}
        build_id=$(echo "$s" | grep -e '^Build ID: ' | cut -s -d ':' -f 2 | sed -e 's/^\s*//' | cut -d ' ' -f 1)
        task_id=$(echo "$s" | grep -e '^Build Task: ' | cut -s -d ':' -f 2 | sed -e 's/^\s*//' | cut -d ' ' -f 1)
        built_time="$(echo "$s" | grep -e '^Built: ' | cut -s -d ':' -f 2 | sed -e 's/^\s*//' -e 's/\s*$//')"
        [ -n "${build_id}" -a -n "${task_id}" -a -n "${built_time}" ] || return ${F:-1}
        s=$(koji buildinfo ${build_id})
        rpm_owner=$(echo "$s" | grep -e 'Built by: ' | cut -s -d ':' -f 2 |  sed -e 's/^\s*//' | cut -d ' ' -f 1)
        [ -n "${rpm_owner}" ] || return ${F:-1}
        [ ${CI_RPM_KOJI_RAW:-1} -eq 1 ] && built_time=$(date +%s -d "${built_time}")
        echo "${build_id}:${task_id}:${rpm_owner}:${built_time}"
    )
}
